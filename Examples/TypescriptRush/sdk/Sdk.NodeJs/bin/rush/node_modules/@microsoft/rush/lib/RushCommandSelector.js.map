{"version":3,"file":"RushCommandSelector.js","sourceRoot":"","sources":["../src/RushCommandSelector.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,iCAAiC;AACjC,6BAA6B;AAK7B;;;;;;GAMG;AACH,MAAa,mBAAmB;IACvB,MAAM,CAAC,sBAAsB,CAAC,OAAe;QAClD,IAAI,mBAAmB,CAAC,eAAe,EAAE,KAAK,OAAO,EAAE;YACrD,mBAAmB,CAAC,cAAc,CAAC,yCAAyC,OAAO,EAAE;kBACjF,6CAA6C,CAAC,CAAC;SACpD;IACH,CAAC;IAED,kCAAkC;IAC3B,MAAM,CAAC,OAAO,CAAC,eAAuB,EAAE,SAAkB,EAAE,eAAoB;QACrF,MAAM,IAAI,GAAwB,eAAe,CAAC,IAAI,CAAC;QAEvD,IAAI,CAAC,IAAI,EAAE;YACT,2EAA2E;YAC3E,mBAAmB,CAAC,cAAc,CAAC,8DAA8D,CAAC,CAAC;SACpG;QAED,IAAI,mBAAmB,CAAC,eAAe,EAAE,KAAK,OAAO,EAAE;YACrD,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;gBACrB,mBAAmB,CAAC,cAAc,CAAC,yCAAyC,IAAI,CAAC,OAAO,EAAE;sBACtF,6CAA6C,CAAC,CAAC;aACpD;YACD,IAAI,CAAC,WAAW,CAAC,eAAe,EAAE,SAAS,CAAC,CAAC;SAC9C;aAAM;YACL,IAAI,CAAC,MAAM,CAAC,eAAe,EAAE,SAAS,CAAC,CAAC;SACzC;IACH,CAAC;IAEO,MAAM,CAAC,cAAc,CAAC,OAAe;QAC3C,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;QACjC,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC;IAEO,MAAM,CAAC,eAAe;QAC5B,IAAI,OAAO,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE;YAC5B,WAAW;YACX,iDAAiD;YACjD,mFAAmF;YACnF,MAAM,QAAQ,GAAW,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;YACtE,IAAI,QAAQ,KAAK,OAAO,EAAE;gBACxB,OAAO,OAAO,CAAC;aAChB;YACD,IAAI,QAAQ,KAAK,MAAM,EAAE;gBACvB,OAAO,MAAM,CAAC;aACf;SACF;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AAhDD,kDAgDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as colors from 'colors';\r\nimport * as path from 'path';\r\nimport * as rushLib from '@microsoft/rush-lib';\r\n\r\ntype CommandName = 'rush' | 'rushx' | undefined;\r\n\r\n/**\r\n * Both \"rush\" and \"rushx\" share the same src/start.ts entry point.  This makes it\r\n * a little easier for them to share all the same startup checks and version selector\r\n * logic.  RushCommandSelector looks at argv to determine whether we're doing \"rush\"\r\n * or \"rushx\" behavior, and then invokes the appropriate entry point in the selected\r\n * @microsoft/rush-lib.\r\n */\r\nexport class RushCommandSelector {\r\n  public static failIfNotInvokedAsRush(version: string): void {\r\n    if (RushCommandSelector._getCommandName() === 'rushx') {\r\n      RushCommandSelector._failWithError(`This repository is using Rush version ${version}`\r\n        + ` which does not support the \"rushx\" command`);\r\n    }\r\n  }\r\n\r\n  // tslint:disable-next-line:no-any\r\n  public static execute(launcherVersion: string, isManaged: boolean, selectedRushLib: any): void {\r\n    const Rush: typeof rushLib.Rush = selectedRushLib.Rush;\r\n\r\n    if (!Rush) {\r\n      // This should be impossible unless we somehow loaded an unexpected version\r\n      RushCommandSelector._failWithError(`Unable to find the \"Rush\" entry point in @microsoft/rush-lib`);\r\n    }\r\n\r\n    if (RushCommandSelector._getCommandName() === 'rushx') {\r\n      if (!Rush.launchRushX) {\r\n        RushCommandSelector._failWithError(`This repository is using Rush version ${Rush.version}`\r\n          + ` which does not support the \"rushx\" command`);\r\n      }\r\n      Rush.launchRushX(launcherVersion, isManaged);\r\n    } else {\r\n      Rush.launch(launcherVersion, isManaged);\r\n    }\r\n  }\r\n\r\n  private static _failWithError(message: string): never {\r\n    console.log(colors.red(message));\r\n    return process.exit(1);\r\n  }\r\n\r\n  private static _getCommandName(): CommandName {\r\n    if (process.argv.length >= 2) {\r\n      // Example:\r\n      // argv[0]: \"C:\\\\Program Files\\\\nodejs\\\\node.exe\"\r\n      // argv[1]: \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\@microsoft\\\\rush\\\\bin\\\\rushx\"\r\n      const basename: string = path.basename(process.argv[1]).toUpperCase();\r\n      if (basename === 'RUSHX') {\r\n        return 'rushx';\r\n      }\r\n      if (basename === 'RUSH') {\r\n        return 'rush';\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"]}